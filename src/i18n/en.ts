import type { Translations } from './types'

export const en: Translations = {
  header: {
    home: 'Home',
    vote: 'Vote',
    connect: 'Connect',
    connecting: '...',
    disconnect: 'Disconnect',
    wrongNetwork: 'Wrong Network',
    switching: 'Switching...',
    balance: 'Voting Power (per proposal)',
    newProposal: 'New Proposal',
    resetData: 'Reset Test Data',
    resetConfirm: 'This will delete all test data (registration, vote history, keys) for this account. Continue?',
    resetDone: 'Reset complete! Refreshing page.',
    technology: 'Technology',
    menu: 'Menu',
    disconnectConfirm: 'Disconnect wallet?',
    disconnectYes: 'Disconnect',
    disconnectNo: 'Cancel',
    testnet: 'Testnet',
  },
  landing: {
    badge: 'ZK Private Voting Protocol',
    title: 'Your Vote.\nYour Secret.',
    subtitle: 'DAO votes are public. Whales dominate. Bribes go unchecked. SIGIL fixes all three.',
    enterApp: 'Launch App',
    heroStatus: 'Protocol Status: Operational',
    heroVersion: 'By Tokamak Network',
    heroLabel1: '01 / ZK-PROOFS',
    heroLabel2: '02 / ANTI-COLLUSION',
    zeroExposure: { title: 'Groth16 Verified', desc: 'Every vote sealed by zero-knowledge proofs and verified on Ethereum.' },
    maciSecured: { title: 'PSE MACI', desc: 'Built on Ethereum Foundation\'s Privacy & Scaling Explorations research.' },
    coreFeatures: 'Core Features',
    features: {
      privacy: { title: 'Permanent Privacy', sub: '', desc: 'Individual votes are cryptographically sealed and never revealed — not even after voting ends.' },
      coercion: { title: 'Bribe-Proof', sub: '', desc: 'Key-change technology makes it impossible to prove how you voted, destroying any bribery market.' },
      fairness: { title: 'Whale-Resistant', sub: '', desc: 'Quadratic voting makes influence exponentially expensive. Casting 10 votes costs 100 credits. Even with more tokens, influence only grows as the square root of your budget.' },
      verified: { title: 'On-chain Verified', sub: '', desc: 'Groth16 proofs are published on Ethereum. Anyone can independently verify the tally.' },
    },
    operationalFlow: 'How Privacy Is Guaranteed',
    lifecycle: {
      title: 'Three Layers of Protection',
      label: 'Three Security Layers',
      step1: { title: 'Encryption', desc: 'Your vote is encrypted in your browser using an ECDH shared key and Poseidon cipher before being submitted to the blockchain. What gets stored on-chain is a meaningless sequence of numbers — decryption without the shared secret is mathematically impossible.' },
      step2: { title: 'Anti-Bribery', desc: 'If coerced, change your voting key and re-vote. Key-change messages and vote messages have identical formats on the blockchain — nobody can distinguish which is which.' },
      step3: { title: 'Verified Tally', desc: 'The coordinator decrypts all messages and tallies votes. During this process, the coordinator can see individual votes, but cannot publish results without a valid ZK proof. Manipulating even one vote causes the proof to fail.' },
    },
    optionA: 'Option Alpha',
    optionB: 'Option Beta',
    whyMaci: {
      title: 'Why SIGIL?',
      anti: {
        title: 'The Only Combined Stack',
        sub: '',
        desc: 'No other voting protocol combines ZK private voting, quadratic fairness, and MACI anti-collusion in one system. SIGIL is the only platform offering all three.',
      },
      privacy: {
        title: 'Key Change Defense',
        sub: '',
        desc: 'Being coerced? Change your voting key. Previous votes are automatically invalidated during tallying. The coercer will never know.',
      },
      verify: {
        title: 'Open SDK for Any DAO',
        sub: '',
        desc: 'Integrate private voting into your project with the SIGIL SDK and embeddable widget. No custom smart contract development required.',
      },
    },
    terminalAccess: 'Quick Links',
    connectDiscord: 'Connect Discord',
    sourceCode: 'Source Code',
    documentation: 'How It Works',
    proofVerified: 'Proof Verified',
    contactSales: 'Contact Sales',
    integration: {
      title: 'Integrate in\nMinutes',
      subtitle: 'Add private, coercion-resistant voting to your DAO with a single package. No backend required.',
      step1Title: 'Install',
      step1Code: 'npm install sigil-sdk',
      step1Desc: 'One package. Zero server dependencies. Works on Ethereum out of the box.',
      step2Title: 'Configure',
      step2Code: "const sigil = new SigilClient({\n  maciAddress: '0x...',\n  provider: yourProvider\n})",
      step2Desc: 'Point to your MACI contract. All cryptographic operations handled automatically.',
      step3Title: 'Launch',
      step3Code: "mountSigilWidget({ target: '#vote', pollId: 0 })",
      step3Desc: 'Mount the voting widget or use the SDK API directly. Your users vote in one click.',
      trustTitle: 'Why You Can Trust SIGIL',
      trust1: 'Open Source — MIT licensed, fully auditable code',
      trust2: 'Ethereum Native — Groth16 on-chain proof verification',
      trust3: 'PSE MACI — Built on Ethereum Foundation research',
      trust4: 'Results Only — Coordinator tallies votes but individual choices are never published',
      comingSoon: 'SDK v0.1.0 — Available on NPM',
    },
    stats: {
      testsCount: '440',
      testsLabel: 'Automated Tests Passed',
      contractsCount: '~10 min',
      contractsLabel: 'Vote to Result Time',
      propertiesCount: '7',
      propertiesLabel: 'Security Properties',
      licenseCount: 'MIT',
      licenseLabel: 'Open Source',
    },
    established: 'EST. 2026',
    sdkIntegration: 'SDK Integration',
    demo: {
      title: 'Try It Now',
      subtitle: 'Three steps. No signup. Free on testnet.',
      placeholder: 'Voting Process Flow',
      note: 'Full flow: Connect → Encrypt → Submit → Prove → Verify',
      stepSubmit: 'Vote is encrypted in your browser and submitted on-chain. Nobody can read it.',
      stepProof: 'Coordinator generates a ZK proof. Any manipulation is mathematically detected.',
      stepResult: 'Only aggregate results are published. Individual votes stay sealed forever.',
      network: 'Ethereum Sepolia Testnet',
      comingSoon: 'Live on Sepolia — Try Free',
    },
    comparison: {
      title: 'How SIGIL Compares',
      subtitle: 'The only voting protocol with all three: permanent privacy, anti-bribery, and quadratic fairness.',
      feature: 'Feature',
      permanentPrivacy: 'Permanent Privacy',
      antiBribery: 'Anti-Bribery',
      quadraticVoting: 'Quadratic Voting',
      onChainVerify: 'On-Chain Verification',
      automation: 'Automated Tally',
      erc20Support: 'On-Chain ERC20 Voice Credits',
      serverlessTally: 'Serverless Coordinator',
      yes: 'Yes',
      no: 'No',
      partial: 'Partial',
      plugin: 'Plugin',
      offchain: 'Off-chain',
      demoStage: 'Demo',
      ownChain: 'Own Chain',
      postReveal: 'Post-Reveal',
      postRevealDev: 'Planned',
      native: 'Native',
      free: 'Free (GitHub)',
      selfHosted: 'Self-Hosted',
      onlyStack: 'Only SIGIL combines all three.',
    },
    transparency: {
      title: 'What Is Visible On the Blockchain?',
      visibleTitle: 'Publicly Visible',
      hiddenTitle: 'Never Exposed',
      visible1: 'Encrypted messages (meaningless number sequences)',
      visible2: 'Aggregate results (total For / Against)',
      visible3: 'ZK proofs (for mathematical correctness verification)',
      hidden1: 'Individual vote choices (For / Against)',
      hidden2: 'Who voted which way',
      hidden3: 'Who changed their key and re-voted',
      coordinatorTitle: 'The Coordinator\'s Role',
      coordinatorNote: 'The coordinator decrypts individual votes during tallying. However, it cannot manipulate results (the ZK proof would fail), and cannot prove anyone\'s final vote to a third party (the voter may have changed their key).',
    },
    contracts: {
      title: 'Verified On-Chain',
      subtitle: 'All contracts are deployed and verified on Ethereum Sepolia.',
      maci: 'MACI Registry',
      accQueue: 'AccQueue (State)',
      token: 'TON Token (Voice Credits)',
      viewOn: 'View on Etherscan',
    },
    roadmap: {
      title: 'Roadmap',
      subtitle: 'Where we are and where we\'re going.',
      phase1: { title: 'Sepolia Testnet Launch', status: 'Complete' },
      phase2: { title: 'SDK v0.1.0 on NPM', status: 'Complete' },
      phase3: { title: 'Production Circuits (depth 4, 624 voters)', status: 'Complete' },
      phase4: { title: 'Community Audit + Bug Bounty', status: 'In Progress' },
      phase5: { title: 'Ethereum Mainnet Launch', status: 'Planned' },
      phase6: { title: 'Multi-Chain (Base, Arbitrum, Polygon)', status: 'Planned' },
    },
    advantages: {
      title: 'Why SIGIL?',
      subtitle: 'Not a demo. Production infrastructure designed to work with your existing stack.',
      erc20: { title: 'Any ERC20 Token', desc: 'Use your existing governance token as voting credits. No custom token required — just point to any ERC20 contract.' },
      serverless: { title: 'Zero Infrastructure', desc: 'No backend, no database, no server to maintain. The frontend is a static site (Vercel/GitHub Pages). The coordinator runs on GitHub Actions — completely free.' },
      l2: { title: 'L2 Ready', desc: 'Standard Solidity contracts deploy on any EVM chain. On Base or Arbitrum, gas costs drop ~100x and the pipeline runs ~6x faster.' },
      tokenGate: { title: 'Community Proposals', desc: 'Token holders can create proposals directly — not just admins. Set a threshold (e.g. 100 tokens) and governance becomes community-driven.' },
      widget: { title: 'Framework Agnostic', desc: 'The embeddable widget is pure vanilla JS. Works in React, Vue, Angular, Svelte, or a plain HTML page. Just add a script tag.' },
      autoTally: { title: 'Fully Automated', desc: 'A GitHub Actions cron job checks for ended polls every 5 minutes, generates proofs, and publishes results on-chain. Zero manual intervention.' },
    },
    faq: {
      title: 'Frequently Asked Questions',
      subtitle: 'Common questions about SIGIL.',
      q1: 'Is my vote really private? Can the coordinator see it?',
      a1: 'The coordinator can see individual votes during the tallying process. However, manipulating results causes the ZK proof to fail, making on-chain publication impossible. And since voters can change their keys, the coordinator cannot prove anyone\'s final vote to a third party. Only aggregate results (total For/Against) are published.',
      q2: 'How much does it cost to use?',
      a2: 'Currently free on Sepolia testnet. On Ethereum mainnet, each proof batch costs approximately 300K gas. Voters pay a small gas fee per vote transaction. On L2 networks (Base, Arbitrum), gas costs are ~100x cheaper.',
      q3: 'How many voters can participate?',
      a3: 'Up to 624 voters per poll in production configuration (quinary state tree depth 4). The current testnet runs at depth 2 (max 4 voters) and will be expanded for mainnet.',
      q4: 'Has the code been audited?',
      a4: 'The codebase is fully open source (MIT license) with 440+ automated tests and 7 cryptographic security properties verified. Built on Ethereum PSE MACI research. Community audit and formal audit are planned before mainnet.',
      q5: 'Which blockchains are supported?',
      a5: 'Currently deployed on Ethereum Sepolia testnet. Ethereum mainnet is the primary target. The contracts are standard Solidity, so deploying on any EVM chain (Base, Arbitrum, Polygon, etc.) requires no code changes.',
      q6: 'What if someone forces me to vote a certain way?',
      a6: 'Change your voting key. This silently invalidates all previous votes. Re-vote with your true choice using the new key. The coercer cannot detect the key change — it looks like any other encrypted message.',
      q7: 'Do I need to run a server?',
      a7: 'No. The voting frontend is a static site you can host on Vercel, Netlify, or GitHub Pages. The coordinator (which tallies votes) runs as a GitHub Actions cron job — completely free for public repos. If you need faster processing, you can run the coordinator on your own server instead.',
      q8: 'Can I use my own governance token?',
      a8: 'Yes. SIGIL uses an ERC20VoiceCreditProxy that reads any ERC20 token balance as voting credits. If your DAO has a governance token, your members\' token balances automatically become their voting power. No migration or wrapping needed.',
    },
    cta: {
      title: 'Your DAO Deserves Better Governance.',
      button: 'Try Free on Testnet',
      step1: 'Connect Wallet',
      step2: 'Vote',
      step3: 'See Results',
    },
  },
  maci: {
    title: 'Private Voting',
    notDeployed: 'Not Deployed',
    notDeployedDesc: 'The voting system is not ready yet. Please contact the administrator.',
    notDeployedHint: 'Then update src/config.json with the deployed addresses.',
    connectWallet: 'Connect your wallet to participate in voting.',
    description: 'Votes are encrypted and cannot be revealed. Key changes invalidate previous votes, preventing coercion.',
    stepper: {
      createPoll: 'Create Proposal',
      vote: 'Vote',
      result: 'Result',
    },
    stats: {
      registered: 'Registered Voters',
      currentPoll: 'Current Poll',
      none: 'None',
    },
    signup: {
      complete: 'Registered',
      button: 'Register as Voter',
      desc: 'Register to participate in voting. A secret voting key will be generated for you. A small gas fee (ETH) is required.',
      loading: 'Registering...',
      error: 'Registration failed. Please check your network and try again.',
      retry: 'Try Again',
    },
    poll: {
      active: 'Poll #{id} active',
    },
    vote: {
      title: 'Cast Vote',
    },
    results: {
      title: 'Results Finalized',
      desc: 'Vote tallying is complete. Results have been verified on-chain.',
    },
    lastTx: 'Last Tx:',
    waiting: {
      merging: 'Voting ended. Waiting for data merge...',
      processing: 'Processing votes. Coordinator is generating proofs...',
    },
  },
  createPoll: {
    title: 'Create New Proposal',
    titleLabel: 'Proposal Title',
    titleMin: 'At least 3 characters required',
    titlePlaceholder: 'e.g. Community Fund Allocation',
    descLabel: 'Description (optional)',
    descPlaceholder: 'Describe the proposal',
    durationLabel: 'Voting Duration',
    durationHours: 'hours',
    durationHint: 'Quick votes: 1-2 hours. Standard votes: 24-72 hours.',
    submit: 'Create Proposal',
    submitting: 'Creating Proposal...',
    error: 'Failed to create proposal',
    errorOwner: 'Only the contract owner can create proposals',
    errorTokens: 'Insufficient tokens to create a proposal',
    checkingEligibility: 'Checking eligibility...',
    notEligible: 'Only admins can create proposals',
    ownerOnly: 'Currently, only the system administrator can create new proposals. Please contact the admin.',
    tokenRequired: 'Token ownership is required to create a proposal.',
    required: 'Required',
    yourBalance: 'Your balance',
    eligible: 'Eligible',
    success: 'Proposal Created!',
    successDesc: 'Your proposal is now live. Community members can start voting.',
    viewProposal: 'View Proposal',
    close: 'Close',
    stageSubmitting: 'Submitting proposal...',
    stageConfirming: 'Please approve in your wallet...',
    stageWaiting: 'Waiting for confirmation...',
    enableCommunity: 'Allow Community Proposals',
    enableCommunityDesc: 'Currently only you (admin) can create proposals. Click the button below to allow any token holder to create proposals.',
    enabling: 'Setting up...',
    gateEnabledSuccess: 'Community proposals are now enabled!',
    draftPhase: 'Draft Phase',
    markdownSupported: 'Markdown Supported',
    generateProposal: 'Generate Proposal',
    guidelinesTitle: 'How to Write a Proposal',
    stakingTitle: 'Writing a Title',
    stakingDesc: 'Be specific about what is being decided. Example: "Approve 200 Token Community Grant"',
    privacyGuideTitle: 'Setting Duration',
    privacyGuideDesc: 'We recommend at least 3 days to ensure sufficient participation. Tallying starts automatically after the period ends.',
    windowTitle: 'Writing a Description',
    windowDesc: 'Explain why this proposal is needed and what changes it will bring. Be specific.',
    quorumTitle: 'After Creation',
    quorumDesc: 'Voting starts immediately after creation. Results are automatically tallied and published on-chain when the period ends.',
    networkOptimal: 'Network Status: Optimal',
    networkOffline: 'Network Offline',
    preset1m: '1 Min',
    preset5m: '5 Min',
    preset1h: '1 Hour',
    preset3d: '3 Days',
    preset7d: '7 Days',
    preset14d: '14 Days',
    presetCustom: 'Custom',
    hoursUnit: 'Hours',
    minutesUnit: 'Minutes',
    noDescPlaceholder: 'No description',
    getTokens: 'How to get tokens',
  },
  voteForm: {
    title: 'Cast Your Vote',
    desc: 'Your vote is encrypted before submission. The coordinator tallies results but cannot manipulate them or prove any individual vote to a third party.',
    against: 'Against',
    for: 'For',
    weightLabel: 'Vote Strength',
    cost: 'Cost:',
    credits: 'credits',
    myCredits: 'My Vote Credits',
    creditsTooltip: 'Vote credits are points you can spend on voting. Higher strength costs more credits. You can spend them all on one proposal or spread across many.',
    weightTooltip: 'Higher strength means more influence, but costs the square of your strength. Example: strength 3 = 9 credits. This prevents any one person from dominating all votes.',
    creditExceeded: 'Not enough credits! Lower your vote strength.',
    costWarning: 'High strength consumes many credits',
    submit: 'Submit Encrypted Vote',
    submitting: 'Encrypting & Submitting...',
    success: 'Vote submitted!',
    error: 'Vote submission failed. Please check your network.',
    errorGas: 'Insufficient ETH. Please top up your Sepolia ETH.',
    errorRejected: 'Rejected in your wallet. Please try again.',
    stageRegistering: 'Registering as voter...',
    stageEncrypting: 'Encrypting your vote...',
    stageSigning: 'Generating secure signature...',
    stageConfirming: 'Please approve in your wallet...',
    stageWaiting: 'Waiting for confirmation...',
    stageDone: 'Vote complete!',
    stageKeyChange: 'Enhancing security...',
    processing: 'Processing Vote',
    patience: 'This includes encryption for your security. It may take 10-30 seconds.',
    successNext: 'Your vote has been securely recorded. When voting ends, the operator will tally results. You can check the results on this page.',
    retry: 'Try Again',
    autoRegisterNotice: 'First-time voters are automatically registered. Your wallet will ask for approval twice.',
    estimatedGas: 'Estimated gas fee',
    yourEthBalance: 'Your ETH balance',
    lowBalance: 'ETH may be insufficient. Please top up your Sepolia testnet ETH.',
    firstVoteNote: 'First vote requires register + vote = 2 transactions',
    noCreditsTitle: 'No Vote Credits',
    noCreditsDesc: 'You need tokens to vote',
    errorRejectedFriendly: 'You cancelled the transaction',
    errorGasFriendly: 'Insufficient ETH balance',
    errorGeneric: 'A temporary error occurred. Please try again.',
    errorTimeout: 'Transaction timed out. Please check Etherscan and try again.',
    errorEncryption: 'Encryption error. Please refresh and try again.',
    quadraticGuide: '1 vote = 1 credit, 3 votes = 9 credits',
  },
  keyManager: {
    title: 'Vote Protection',
    expandLabel: 'Anti-Coercion Protection',
    tooltip: 'Being forced to vote a certain way? Change your key to automatically invalidate your previous vote. Then re-vote with your true choice. The person who pressured you will never know you changed it.',
    currentKey: 'Current key status:',
    keyActive: 'Protection active',
    noKey: 'No key registered yet.',
    noKeyReason: 'A protection key will be created automatically on your first vote.',
    changeKey: 'Change Key (Invalidate Previous Votes)',
    warning: 'Changing your key will invalidate ALL previous votes. You must re-vote after changing.',
    confirm: 'Confirm Key Change',
    changing: 'Changing...',
    cancel: 'Cancel',
    success: 'Key changed. Your previous votes are now invalid. Please submit a new vote.',
    error: 'Key change failed. Please try again.',
  },
  merging: {
    title: 'Preparing Results',
    desc: 'Voting has ended. The coordinator will automatically begin tallying. The full process (prep → tally → results) usually takes 5-10 minutes.',
    stateQueue: 'Step 1: Registration Data',
    messageQueue: 'Step 2: Encrypted Votes',
    merged: 'Done',
    pending: 'Processing...',
    allMerged: 'Data preparation complete. Results will be tallied soon.',
    elapsed: 'Elapsed',
    estimate: 'Usually takes 1-3 min',
    stuck: 'Processing is delayed',
    stuckDesc: 'The coordinator has not responded yet. It will automatically retry shortly.',
    stateQueueDesc: 'Organizing registered voter data',
    messageQueueDesc: 'Organizing encrypted vote messages',
    timelineNote: 'Prep (1-3 min) → Tally (3-5 min) → Results. Coordinator checks automatically every 30 seconds.',
  },
  processing: {
    title: 'Tallying Votes',
    desc: 'Encrypted votes are being securely tallied. ZK proof generation takes about 3-5 minutes.',
    step1: 'Analyzing Encrypted Votes',
    step2: 'Tallying & ZK Proof Generation',
    step3: 'Publishing Results On-chain',
    inProgress: 'In progress...',
    complete: 'Complete',
    waiting: 'Waiting',
    verified: 'Verified on-chain',
    elapsed: 'Elapsed',
    estimate: 'Usually takes 3-5 min',
    stuck: 'Processing is delayed',
    stuckDesc: 'Proof generation is taking time. It will automatically retry shortly.',
    timelineNote: 'The coordinator generates ZK proofs and submits them to Ethereum. Results appear automatically when complete.',
  },
  tallying: {
    banner: 'Voting Closed \u2014 Tallying Results',
    phase: 'Tallying Phase',
    proposalContext: 'Proposal Context',
    privacyAssurance: 'Privacy Assurance',
    zkEnvironment: 'ZK-Encrypted Environment',
    processingStatus: 'Processing Status',
    step01: 'Step 01',
    step02: 'Step 02',
    currentPhase: 'Current Phase',
    finalStep: 'Final Step',
    processing: 'Processing...',
    estimatedRemaining: 'Estimated Remaining',
    remaining: 'remaining',
    myVoteSummary: 'My Vote Summary',
    choice: 'Choice',
    spent: 'Spent',
    participation: 'Participation',
    totalUsers: 'Total Users',
    privacyDesc: 'Votes are permanently private. Not even the coordinator can prove any individual vote to a third party.',
    systemOperational: 'System Operational',
    zkProofActive: 'ZK-Proof Generation Active',
    copyright: '\u00A9 2026 SIGIL — Built by Tokamak Network',
  },
  failed: {
    title: 'Awaiting Tally',
    desc: 'Voting has ended, but the coordinator has not yet tallied the results.',
    reason: 'The coordinator auto-runner service may not be running, or encountered an error during processing. Results will be tallied automatically once the coordinator is started.',
    newPollHint: 'Please ask your administrator to start the coordinator service.',
    errorDetails: 'Status Details',
    processingError: 'Tally Pending',
    suggestedAction: 'Suggested Action',
    createNew: 'Create New Proposal',
    statusFailed: 'Pending',
    coordinatorHint: 'Please start the coordinator auto-runner service. Once running, it will automatically tally all ended polls.',
  },
  results: {
    title: 'Vote Results',
    desc: 'Final results verified by zero-knowledge proofs.',
    passed: 'Passed',
    rejected: 'Rejected',
    tied: 'Tied',
    totalVoters: 'Voters',
    totalVotes: 'Total votes',
    verified: 'Verified on-chain',
    noVotes: 'No votes',
    noVotesYet: 'No vote results yet',
    allInvalid: 'No valid votes. All votes were invalidated due to key mismatch.',
    forLabel: 'For',
    againstLabel: 'Against',
    creditsUnit: 'credits',
    retry: 'Try Again',
  },
  noVotes: {
    title: 'No Votes',
    desc: 'No one voted on this proposal. There are no results to tally.',
    status: 'No Votes',
  },
  timer: {
    remaining: 'Time left',
    ended: 'Voting ended',
    hours: 'Hours',
    minutes: 'Minutes',
    seconds: 'Seconds',
    tallyCountdown: 'Time Remaining Until Tally',
    processingHint: 'Results will be processed soon',
  },
  confirm: {
    title: 'Confirm Your Vote',
    choice: 'Choice',
    weight: 'Weight',
    cost: 'Cost',
    notice: 'Your vote will be encrypted and submitted. After submission, you can only invalidate it by changing your key.',
    submit: 'Submit Vote',
    cancel: 'Cancel',
  },
  proposals: {
    title: 'Proposals',
    loading: 'Loading proposals...',
    empty: 'No proposals yet. Be the first to create one!',
    emptyHint: 'Click the "New Proposal" button above to start your first vote.',
    createNew: 'New Proposal',
    status: {
      active: 'Active',
      ended: 'Ended',
      finalized: 'Finalized',
    },
    emptyAction: 'Create First Proposal',
    messages: 'votes',
    backToList: 'All Proposals',
    voted: 'Voted',
    notVoted: 'Not voted',
    noFiltered: 'No matching proposals',
    filterAll: 'All',
    filterVoting: 'Voting',
    filterProcessing: 'Processing',
    filterEnded: 'Ended',
    daoGovernance: 'DAO Governance',
    subtitle: 'Participate in ZK-proof based anonymous voting.',
    participants: 'Vote Messages',
    calculating: 'Calculating...',
    result: 'Result',
    statusVoting: 'Voting',
    statusRevealing: 'Tallying',
    statusEnded: 'Ended',
  },
  voteHistory: {
    alreadyVoted: 'You have already voted on this proposal.',
    overrideWarning: 'In MACI, only your first submitted vote counts in the final tally. Re-voting is only effective after a key change.',
    lastChoice: 'Your choice',
    lastWeight: 'Weight',
    lastCost: 'Credits spent',
    creditsRemaining: 'Credits remaining',
  },
  myVote: {
    title: 'My Vote',
    noVote: 'You did not vote on this proposal.',
  },
  footer: {
    desc: 'Open-source private voting infrastructure on Ethereum. Built by Tokamak Network.',
    resources: 'Resources',
    whitepaper: 'MACI Protocol',
    audit: 'Source Code',
    sdk: 'Documentation',
    social: 'Social',
    copyright: '\u00A9 2026 SIGIL — Built by Tokamak Network',
    secured: 'Sealed by Zero-Knowledge Proofs',
    builtBy: 'Built by',
    systemOperational: 'System Operational',
    protocolVersion: 'MACI Protocol',
    node: 'NODE: SIGIL-01-AMS',
    privacyFirst: 'Privacy First',
    antiBribery: 'Anti-Bribery',
    verifiedTally: 'Verified Tally',
    terms: 'Terms',
    privacy: 'Privacy Policy',
    poweredBy: 'Protocol Powered By',
    coreInfra: 'Core Infrastructure',
  },
  proposalDetail: {
    currentStatus: 'Current Status',
    votingOpen: 'Voting Open',
    proposalDesc: 'Proposal Description',
    totalParticipants: 'Total Participants',
    users: 'Users',
    currentWeight: 'Current Weight',
    alreadyVotedBanner: 'You have already voted. Re-voting is only effective after a key change.',
    reVote: 'Re-Vote (After Key Change)',
    voteSubmitted: 'Vote Submitted',
    receiptId: 'Receipt ID',
    yourSelection: 'Your Selection',
    intensity: 'Intensity',
    totalCost: 'Total Cost',
    changedMind: 'Changed your key? Re-vote now.',
    encryptedProof: 'Encrypted on-chain proof generated',
    proposalPrefix: 'Proposal',
  },
  completedResults: {
    title: 'Completed Results',
    votingBreakdown: 'Voting Breakdown',
    quadraticCredits: 'Quadratic Credits',
    finalTally: 'Final Tally Detailed',
    uniqueAddresses: 'Unique Addresses',
    quadraticMagnitude: 'Quadratic Magnitude',
    zkVerified: 'ZK-Proof Verified on Ethereum',
    viewOnExplorer: 'View on Explorer',
    proposalDetails: 'Proposal Details',
    titleLabel: 'Title',
    author: 'Author',
    description: 'Description',
    readFull: 'Read Full Proposal Description',
    defaultDesc: 'This proposal was created through SIGIL private voting protocol with ZK-proof verified secret ballots. All votes were encrypted using MACI anti-collusion infrastructure and tallied with Groth16 zero-knowledge proofs on Ethereum.',
    votingStrategy: 'Voting Strategy: Quadratic v2',
    shieldedVoting: 'Shielded Voting: Enabled',
    contractLabel: 'Contract',
  },
  voteSubmittedPage: {
    title: 'Vote Submitted Securely',
    txHash: 'Transaction Hash',
    proposal: 'Proposal',
    myChoice: 'My Choice',
    votingStats: 'Voting Stats',
    intensity: 'Intensity',
    used: 'Used',
    votes: 'Votes',
    viewOnExplorer: 'View on Explorer',
    txConfirmed: 'Transaction confirmed on-chain',
    returnToList: 'Return to Proposal List',
    privacyStatus: 'Privacy Status',
    maciShield: 'MACI Shield Active',
    proofs: 'Proofs',
    zkProofGenerated: 'ZK-Proof Generated',
  },
  voteFormExtra: {
    quadraticScaling: 'Quadratic Scaling',
    minCredit: 'MIN: 1 CREDIT',
    maxCredits: 'MAX: {n} CREDITS',
  },
  technology: {
    nav: 'Technology',
    title: 'The Technology\nBehind SIGIL',
    subtitle: 'Three cryptographic pillars — privacy, fairness, and anti-collusion — work in concert. Each vote is encrypted, quadratically weighted, and shielded from bribery by Ethereum PSE research.',
    heroBadge: 'Technical Documentation',
    zkVoting: {
      title: 'ZK Private Voting',
      badge: 'Zero-Knowledge Proofs',
      desc: 'Votes are mathematically sealed using Poseidon hash commitments. A Groth16 zero-knowledge proof verifies eligibility through a snapshot Merkle tree, confirms correct vote structure, and proves ownership — all without revealing what you voted for. There is no reveal phase. Individual votes are permanently encrypted.',
      howTitle: 'How It Works',
      howDesc: 'When you vote, a Poseidon commitment locks your choice: H(choice, votingPower, proposalId, salt). A ZK proof then verifies your governance token via Merkle inclusion in a historical snapshot, confirms ownership via Baby Jubjub key derivation, and checks that voting power matches your token balance — without exposing any of these values.',
      point1: 'Choice is never stored in plaintext — only the Poseidon hash commitment exists on-chain',
      point2: 'Merkle proof verifies token ownership at a historical snapshot, preventing manipulation',
      point3: 'No reveal phase exists — individual votes are permanently sealed, even after voting ends',
      commitLabel: 'Poseidon Commitment (On-Chain)',
      commitFormula: 'Poseidon(choice, votingPower, proposalId, voteSalt)',
      proofValid: 'Groth16 Proof Verified',
    },
    quadratic: {
      title: 'Quadratic Voting',
      badge: 'Fair Influence',
      desc: 'Traditional "1 token = 1 vote" cannot distinguish mild preferences from strong convictions, and gives whales unchecked power. Quadratic voting fixes both: influence costs grow exponentially, so passionate minorities can outweigh apathetic majorities, while no single entity can dominate outcomes.',
      howTitle: 'How It Works',
      howDesc: 'Each voter receives voice credits. Casting more votes on the same proposal costs quadratically more: cost = votes². One vote costs 1 credit, but 10 votes costs 100 credits. This forces voters to budget their influence across proposals, naturally preventing plutocratic domination while letting conviction shine through.',
      example: 'Visual Progression of Exponential Cost',
      vote1: '1 Vote',
      vote2: '2 Votes',
      vote3: '3 Votes',
      creditUnit: 'credits',
      formula: 'Credit System: Cost = Vote\u00B2',
    },
    antiCollusion: {
      title: 'MACI Anti-Collusion',
      badge: 'Ethereum PSE Research',
      desc: 'Built on Ethereum Privacy & Scaling Explorations (PSE) research. Every vote is encrypted with Poseidon DuplexSponge and signed with EdDSA. The Key Change mechanism makes bribery economically irrational — even if coerced, you can secretly override your vote. The Coordinator processes messages in reverse order, so the last key always wins.',
      howTitle: 'How It Works',
      howDesc: 'Votes are encrypted via ECDH shared key with the Coordinator and stored in an immutable AccQueue on-chain. During tallying, messages are processed last-to-first. If you changed your key after being coerced, the coerced vote\'s signature no longer matches — it is silently routed to a null state. The briber cannot tell.',
      scenario: 'Forced Vote (Coerced)',
      step1: 'A briber forces Alice to vote "For" and watches her submit it on-chain. She complies to appear cooperative.',
      step2: 'Alice secretly changes her EdDSA key. The briber cannot detect this — it looks like any other encrypted message.',
      step3: 'Alice re-votes with her true choice using the new key. During reverse-order processing, only this vote counts.',
      step1Title: 'Forced Vote',
      step2Title: 'Key Change',
      step3Title: 'Real Vote',
      partnership: 'Built on Ethereum Privacy & Scaling Explorations (PSE) research',
    },
    combined: {
      title: 'Stronger Together',
      desc: 'SIGIL is the only voting protocol that combines all three technologies. Snapshot, Aragon, Tally, Vocdoni — none offers ZK permanent privacy + quadratic fairness + MACI anti-collusion in a single system. These three layers create synergy that no individual technology can achieve alone.',
      diffTitle: 'What SIGIL adds beyond PSE MACI',
      diff1: 'Quadratic Voting — Native D2 integration with cost=votes² credit system, not available in vanilla MACI',
      diff2: 'In-Circuit Decryption — DuplexSponge runs inside the ZK circuit, removing the trust assumption on the coordinator\'s decryption',
      diff3: 'Permanent Privacy — No reveal phase. Individual votes are never published, even after voting ends',
      diff4: 'ERC20 Voice Credits — Any governance token works as voting power via ERC20VoiceCreditProxy',
      diff5: 'Serverless Coordinator — GitHub Actions cron replaces the need for a dedicated server',
    },
    specs: {
      title: 'Technical Specifications',
      subtitle: 'Concrete numbers behind the cryptography',
      proofTime: { label: 'Proof Generation', value: '~2-3s', desc: 'Groth16 ZK proof generation per batch (testnet, depth 2). Production depth 4 estimated ~30-60s.' },
      gasPerBatch: { label: 'Gas per Batch', value: '~300K', desc: 'On-chain verification cost for each proof batch on Ethereum' },
      hashFunction: { label: 'Hash Function', value: 'Poseidon', desc: 't=4, rate=3 — optimized for ZK circuits, 8x faster than SHA256 in-circuit' },
      keyCurve: { label: 'Key Curve', value: 'Baby Jubjub', desc: 'EdDSA-compatible elliptic curve embedded in BN254 scalar field' },
      cipherSuite: { label: 'Encryption', value: 'DuplexSponge', desc: 'Poseidon-based sponge cipher + ECDH key exchange for vote encryption' },
      treeDepth: { label: 'State Tree', value: 'Depth 4', desc: 'Quinary tree — supports up to 624 voters per poll (production configuration)' },
      msgConstraints: { label: 'MessageProcessor', value: '280,841', desc: 'R1CS constraints for message decryption, key change, and state transition proof' },
      tallyConstraints: { label: 'TallyVotes', value: '88,504', desc: 'R1CS constraints for vote counting and tally commitment proof' },
      ptau: { label: 'Trusted Setup', value: 'pot20', desc: 'Powers of Tau ceremony supporting up to 2²⁰ (1M) constraints. Groth16 phase 2 per circuit.' },
    },
    architecture: {
      title: 'System Architecture',
      subtitle: 'How the four core contracts work together',
      step1: { title: 'MACI', desc: 'Entry point. Handles voter registration (signUp) and deploys new Poll instances.' },
      step2: { title: 'Poll', desc: 'Stores encrypted vote messages in an immutable AccQueue. Manages voting period.' },
      step3: { title: 'MessageProcessor', desc: 'Decrypts messages in reverse order. Applies key changes. Generates state transition proof.' },
      step4: { title: 'Tally', desc: 'Computes final vote counts. Generates Groth16 tally proof. Publishes results on-chain.' },
    },
    pipeline: {
      title: 'Tallying Pipeline',
      subtitle: 'When voting ends, the coordinator automatically begins tallying. Each step requires blockchain transactions, and the entire process takes approximately 2-3 minutes.',
      total: 'Total time: ~2-3 minutes (testnet)',
      step1: { title: 'Data Merge', desc: 'Voter list and encrypted messages are merged into Merkle trees. Requires 4 blockchain transactions.', time: '~50s' },
      step2: { title: 'Message Processing', desc: 'The coordinator decrypts all messages in reverse order, applies key changes, and identifies valid votes. A ZK proof is generated and submitted on-chain for each batch.', time: '~50s' },
      step3: { title: 'Tally Proof', desc: 'Valid votes are tallied and a Groth16 proof is generated. This proof mathematically guarantees the tally is correct.', time: '~25s' },
      step4: { title: 'Publish Results', desc: 'Aggregate results (total For/Against) are published on-chain. Individual votes are never revealed — only the final totals.', time: '~20s' },
      note: 'ZK proof generation itself takes 2-3 seconds. Most of the time is spent waiting for blockchain transaction confirmations (Sepolia ~12s/block). On L2 networks (Base, Arbitrum), block times are ~2s, making the process much faster.',
    },
    properties: {
      title: 'Security Guarantees',
      subtitle: 'Seven cryptographic properties guaranteed by the MACI protocol',
      collusion: { title: 'Collusion Resistant', desc: 'Only Coordinator decrypts; bribers cannot verify compliance' },
      receipt: { title: 'Receipt-Free', desc: 'Key Change invalidates any "proof" shown to a briber' },
      privacy: { title: 'Vote Privacy', desc: 'No reveal phase — individual votes are permanently encrypted' },
      uncensor: { title: 'Uncensorable', desc: 'Immutable AccQueue — omitting a vote causes proof failure' },
      unforge: { title: 'Unforgeable', desc: 'EdDSA signature required with voter\'s current key' },
      nonrepud: { title: 'Non-Repudiable', desc: 'New votes override, never delete — all messages are permanent' },
      correct: { title: 'Correct Execution', desc: 'Groth16 on-chain verification proves tally correctness' },
    },
    developers: {
      title: 'Built for\nDevelopers',
      subtitle: 'Everything you need to add private voting to any Web3 project.',
      sdkTitle: 'TypeScript SDK',
      sdkDesc: 'Full type safety with autocompletion. Create polls, cast votes, and read results — all client-side with zero backend.',
      sdkCode: 'const sigil = new SigilClient({ maciAddress })\nconst results = await sigil.getResults(pollId)',
      widgetTitle: 'Embeddable Widget',
      widgetDesc: 'Mount a vanilla JS widget into any page. Handles key generation, encryption, and transaction submission automatically.',
      widgetCode: "mountSigilWidget({ target: '#vote', pollId: 0 })",
      apiTitle: 'Crypto Primitives',
      apiDesc: 'Use low-level crypto primitives for maximum flexibility. Command packing, message encryption, and key derivation utilities.',
      apiCode: 'import { packCommand, buildEncryptedVoteMessage } from "sigil-sdk"\nconst msg = await buildEncryptedVoteMessage(params)',
      useCaseTitle: 'Built for Every DAO',
      useCase1: 'Treasury Governance — Allocate funds without whale manipulation',
      useCase2: 'Protocol Upgrades — Vote on parameter changes privately',
      useCase3: 'Grant Allocation — Fair quadratic funding decisions',
      useCase4: 'Community Decisions — NFT, DeFi, and social DAO voting',
      trustTitle: 'Security & Trust',
      trust1: 'MIT License — Fully open source, fork and audit freely',
      trust2: 'PSE MACI Protocol — Built on Ethereum Foundation Privacy & Scaling Explorations research',
      trust3: 'On-chain Groth16 — Every tally verified by smart contract, not a server',
      trust4: 'Zero Knowledge — Coordinator tallies votes but individual choices are never published',
      protocolStack: 'Protocol Stack',
    },
    infrastructure: {
      title: 'Infrastructure & Operations',
      subtitle: 'SIGIL runs with zero backend infrastructure. Everything is either on-chain or client-side. The coordinator can run for free on GitHub Actions, or on your own server for faster processing.',
      serverless: { title: 'Serverless Architecture', desc: 'The voting frontend is a static SPA (Vite build) deployable on Vercel, Netlify, or GitHub Pages. All cryptographic operations (key generation, encryption, signing) happen in the user\'s browser. Smart contracts handle registration and storage on-chain. No backend server, no database, no API to maintain.' },
      erc20: { title: 'ERC20 Voice Credits', desc: 'The ERC20VoiceCreditProxy contract reads any ERC20 token balance and converts it to voice credits (1 token = 1 credit, floor division). Point it at your governance token address during deployment. Token holders\' balances automatically become their quadratic voting budget.' },
      l2: { title: 'L2 / Multi-Chain Deployment', desc: 'All contracts are standard Solidity 0.8.24 with no chain-specific dependencies. Deploy on any EVM-compatible chain. On L2 networks (Base, Arbitrum), gas costs drop ~100x ($0.01 per vote vs ~$1 on mainnet) and block times decrease from ~12s to ~2s, making the entire tallying pipeline ~6x faster.' },
      tokenGate: { title: 'Token-Gated Proposals', desc: 'The MACI contract supports multi-token proposal gates via addProposalGate(token, threshold). When gates are configured, any address holding enough tokens can create proposals — not just the contract owner. Gates can be cleared or reconfigured at any time by the owner.' },
      autoTally: { title: 'GitHub Actions Coordinator', desc: 'The coordinator runs as a GitHub Actions cron job (every 5 minutes). When a poll ends, it automatically: merges AccQueues → decrypts messages → generates Groth16 proofs → publishes results on-chain. Free for public repositories. Uses circuit files cached from GitHub Releases.' },
      customServer: { title: 'Custom Server Option', desc: 'For faster processing, run the coordinator on your own server (npx tsx src/run.ts). It polls every 30 seconds instead of 5 minutes and responds immediately when polls end. Same code, same pipeline — just faster. Requires a funded Ethereum wallet and the coordinator\'s Baby Jubjub private key.' },
    },
    cta: {
      title: 'See It in Action',
      button: 'Try on Testnet',
    },
  },
  governance: {
    delegation: {
      title: 'Delegate Voting Power',
      delegateTo: 'Delegate To',
      addressPlaceholder: '0x... address to delegate to',
      delegate: 'Delegate',
      delegating: 'Delegating...',
      undelegate: 'Remove Delegation',
      undelegating: 'Removing...',
      currentDelegate: 'Current Delegate',
      notDelegating: 'Not delegating — using your own voting power',
      delegateSuccess: 'Delegation successful!',
      undelegateSuccess: 'Delegation removed. Using your own voting power now.',
      error: 'Delegation failed. Please try again.',
      selfDelegateError: 'Cannot delegate to yourself',
      description: 'Delegate your voting power to a trusted address. Your delegate\'s token balance will be used as your voice credits when you register for a poll.',
      nav: 'Delegate',
    },
    execution: {
      title: 'On-Chain Execution',
      register: 'Register Execution',
      registering: 'Registering...',
      schedule: 'Schedule Execution',
      scheduling: 'Scheduling...',
      execute: 'Execute',
      executing: 'Executing...',
      cancel: 'Cancel Execution',
      cancelling: 'Cancelling...',
      registered: 'Registered',
      scheduled: 'Scheduled',
      executed: 'Executed',
      cancelled: 'Cancelled',
      none: 'No Execution',
      timelockRemaining: 'Timelock Remaining',
      readyToExecute: 'Ready to Execute',
      targetAddress: 'Target Contract',
      calldata: 'Calldata (hex)',
      delay: 'Timelock Delay',
      quorum: 'Minimum Voters',
      delayOptions: { hour1: '1 Hour', hour24: '24 Hours', hour48: '48 Hours', day7: '7 Days' },
      executionSection: 'On-Chain Execution (Optional)',
      executionSectionDesc: 'Automatically execute a contract call if this proposal passes.',
      quorumLabel: 'Quorum',
      success: 'Execution registered successfully!',
      error: 'Execution registration failed.',
      executable: 'Executable',
    },
  },
}
